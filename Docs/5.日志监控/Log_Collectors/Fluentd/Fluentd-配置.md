# Fluentd 配置

[TOC]

配置文件的核心是各种命令块(directives)，每一种命令都是为了完成某种处理，命令与命令之前还可以组成串联关系，以 pipline 的形式流式的处理和分发日志。

最常见的方式就是 source 收集日志，然后由串联的 filter 做流式的处理，最后交给 match 进行分发。

同时你还可以用 label 将任务分组，用 error 处理异常，用 system 修改运行参数

- <https://docs.fluentd.org/configuration>

## 配置文件

- <https://docs.fluentd.org/configuration/config-file>

默认情况西安，td-agent使用下面文件作为默认配置运行

`$ sudo vi /etc/td-agent/td-agent.conf`

## 默认Logging

默认情况下，td-agent会将自身的运行日志写入下面文件
`/var/log/td-agent/td-agent.log`

## 配置指令

1. source - directives determine the "input" sources

2. match - directives determine the "output" destinations

3. filter - directives determine the event processing pipelines

4. system - directives set system wide configuration

5. label - directives group the output and filter for internal routing

6. @include -  directives include other files

### 1. source

source 是 fluentd 的一切数据的来源，每一个 source 内都包含一个输入模块，比如原生集成的包含 http 和 forward 两个模块，分别用来接收 HTTP 请求和 TCP 请求：

```xml
# Receive events from 24224/tcp
# This is used by log forwarding and the fluent-cat command
<source>
  @type forward
  port 24224
</source>

# http://this.host:9880/myapp.access?json={"event":"data"}
<source>
  @type http
  port 9880
</source>
```

source dirctive 在获取到输入后，会向 fluent 的路由抛出一个事件，这个事件包含三个要素：

```text
# generated by http://this.host:9880/myapp.access?json={"event":"data"}
tag: myapp.access
time: (current time)
record: {"event":"data"}
```

### 2. match

match 用来指定动作，通过 tag 匹配 source，然后执行指定的命令来分发日志，最常见的用法就是将 source 收集的日志转存到数据库。

``` xml

# http://this.host:9880/myapp.access?json={"event":"data"}
<source>
  @type http
  port 9880
</source>

# 将标记为 myapp.access 的日志转存到文件
<match myapp.access>
  @type file
  path /var/log/fluent/access
</match>
```

编写格式基本于source相同只是在match后面多了一个条件指定.

条件可使用「*」、「**」及「{}」正则表达

| 符号        | 说明   |
| --------   | :-----  |
| *  | 匹配任意字符，但是必须存在 |
|**     |   匹配任意字符，当不存在时也匹配   |
| {}       |   至少匹配括号里的一个单元    |

例如条件为「a.*」时匹配「a.b」标签而不匹配「a」及「a.b.c」标签，当条件为「a.**」时匹配「a」、「a.b」及「a.b.c」标签。

fluentd 按照 match 出现的顺序依次匹配，一旦匹配成功就不会再往下匹配，所以如果你先写了一个 match **，然后后面的所有的 match 都会被忽略。

然后我们使用了 `@type file` 插件来处理事件，这个插件有一个 path 属性，用来指定输出文件。

用法和 source 几乎一模一样，不过 source 是抛出事件，match 是接收并处理事件

### 3. filter

filter 和 match 的语法几乎完全一样，**但是 filter 可以串联成 pipeline**，对数据进行串行处理，最终再交给 match 输出

```xml
# http://this.host:9880/myapp.access?json={"event":"data"}
<source>
  @type http
  port 9880
</source>

<filter myapp.access>
  @type record_transformer
  <record>
    host_param "#{Socket.gethostname}"
  </record>
</filter>

<match myapp.access>
  @type file
  path /var/log/fluent/access
</match>
```

这个例子里，filter 获取数据后，调用原生的 @type record_transformer 插件，在事件的 record 里插入了新的字段 host_param，然后再交给 match 输出

### 4. include

fluentd 的相关设置，可以在启动时设置，也可以在配置文件里设置，包含：

- log_level
- suppress_repeated_stacktrace
- emit_error_log_interval
- suppress_config_dump
- without_source

### 5. label

label 用于将任务进行分组，方便复杂任务的管理。

你可以在 source 里指定 @label @<LABEL_NAME>，这个 source 所触发的事件就会被发送给指定的 label 所包含的任务，而不会被后续的其他任务获取到。

```xml
<source>
  @type forward
</source>

<source>
  # 这个任务指定了 label 为 @SYSTEM
  # 会被发送给 <label @SYSTEM>
  # 而不会被发送给下面紧跟的 filter 和 match
  @type tail
  @label @SYSTEM
</source>

<filter access.**>
  @type record_transformer
  <record>
    # ...
  </record>
</filter>
<match **>
  @type elasticsearch
  # ...
</match>

<label @SYSTEM>
  # 将会接收到上面 @type tail 的 source event
  <filter var.log.middleware.**>
    @type grep
    # ...
  </filter>
  <match **>
    @type s3
    # ...
  </match>
</label>
```

### 6. include

可以在配置文件里使用 @include 来切分你的配置文件，include 支持多种写法：

```conf
    # 绝对路径
    include /path/to/config.conf
    # 相对路径
    @include conf.d/*.conf
    # 甚至 URL
    @include http://example.com/fluent.conf
```
