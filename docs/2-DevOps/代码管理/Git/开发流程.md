# 开发流程

## 开发环境说明

* dev: [开发共享测试环境](http://dev-vwork.vivo.xyz/)

  * 该环境为开发专属的测试环境

* stage [QA测试环境](http://stage-vwork.vivo.xyz/)

  * QA专属的测试环境  

* product [实际生产环境](http://vwork.vivo.xyz/)
  * 保持master最新的代码，作为最终的生产环境

## 开发流程和规范

该章节涵盖了开发团队所采用的开发流程、代码规范、上线流程、文档规范等。

### 代码版本控制和工具

* 项目所有的源代码都通过 Git 进行版本控制，你应该熟练使用Git这个工具，推荐阅读 [Pro Git](https://git-scm.com/book/zh/v2) 和 [Get Git Right](https://www.atlassian.com/git)
* [Gitlab](http://gitlab-vwork.vivo.xyz) 是我们的代码review和Issue管理平台，每个开发者都应该熟练使用 Gitlab，同时，以下文档必读和熟练掌握：

### 代码的分支管理规范

分支模型，我们严格遵守 [git-flow](https://github.com/nvie/gitflow) 分支管理模型，git-flow 总览参考下图：

![Gitflow](http://sdk.quncrm.com/gitflow.gif)

* 永久代码分支：包括 master 和 develop 分支

  * `master` 分支：该分支的HEAD代表了当前生产环境中部署的代码，该分支是稳定的、任何时刻都可以进行生产环境部署的分支；同时，该分支做了代码合并的保护，不能直接 commit code & push to master来更改该分支的代码，只能通过提交 [Merge Request] 在完成代码review和测试后，合并到master分支
  * `develop` 分支：当前active开发的分支，代表了当前最新的开发代码，所有的 bug/feature 分支都从 `develop` 分支分离，在完成后，通过提交 Merge request 合并到 `develop` 分支

* 阶段性代码分支：包括 bug 分支、feature分支以及hotfix分支

  * bug 分支：针对每一个bug，都需要在单独的分支上进行代码修改、完成测试，然后通过Merge request提交到 `develop` 分支
  * feature 分支：针对每一个feature，都需要在单独的分支上进行编码、测试，等整个feature完成后，提交Merge request合并到 `develop` 分支
  * hotfix 分支：针对生产环境上优先级高的Bug，通过从 `master` 分支出 `hotfix` 分支，完成代码修改和测试后，通过Merge request 合并到 `master` 分支，同时 `cherry-pick` 到 `develop` 分支

### Commit message 规范

规定格式如下：

```
<type>(<scope>): <subject> #issue_number

<description>
```

其中，type、scope、subject是必需的，description 可以省略。不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。

#### type 部分取值说明

type用于说明 commit 的类别，只允许使用下面7个标识。

* **feat:** 新功能（feature）
* **fix:** 修补bug
* **docs:** 文档（documentation）
* **style:** 格式（不影响代码运行的变动）
* **refactor:** 重构（即不是新增功能，也不是修改bug的代码变动）
* **test:** 增加测试

如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。

#### scope 部分取值说明

scope用于说明 commit 影响的范围， **用全小写的方式** ，基本原则是优先使用模块名称作为scope的名称。

#### subject 部分
subject是 commit 目的的简短描述，描述做了什么事情，禁止出现 update code ， fix bug 等无实际意义的描述
#### Commit message 延伸阅读
* [Conventional Changelog](https://github.com/ajoslin/conventional-changelog)
* [Commit message 和 Change log 编写指南](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)

### Code review 和 Merge request 规范

#### Code review的目的

* 提高代码质量，查漏补缺。
* 相互学习。
* 促进项目内知识流动，防止对某个个人过分依赖。

#### Code review的流程

* 任何针对bug的代码修改、针对feature的代码，在合并到 `develop`分支之前，都应该进行几轮的代码review，然后才会被接受合并到 `develop` 分支
* 任何针对hotfix的代码修改，都应该经过几轮代码review后，才能被接受合并到 `master`分支

代码被接受合并到 `develop` 分支和 `master` 分支的条件：

* owner 完成代码修改，通过本地的测试
* 针对API的代码修改，完成API的测试代码编写，同时所有的测试代码都能pass
* 提交的MR（merge request，以下简称 MR）被审核者审阅完毕，审阅中发现的问题被修复

基于MR的代码review流程：

1. 提交者发起 `feature/bug` 分支到 `develop` 分支的 Merge Request 。
    - 代码变动要尽量小且专注于单一任务，不要攒的很大，或者做多个任务，要保证审查者可以较快、较容易的 Review 。
    - 禁止在功能开发的过程中，代码改动既包括新功能的代码，又包括对历史代码重构的改动，针对重构的代码，应该单独的MR进行Review
    - 不要把调试代码、注释掉的代码保留在版本控制中，禁止提交此类代码
    - 如果与目标分支有冲突，提交者应该自己使用 `git rebase` 或 `git merge`（共享分支的情况）解决。
    - 交给别人之前一定要自己先 Review 一遍，别人只是帮你查漏补缺，对自己的代码负责，不要浪费别人的时间。
    - 发起后，要在 GitLab 或者其它 Review 工具上 double check 变更集。
2. 审查者 Review 代码。
    - 在任何有疑问或建议的地方留 comment。
    - 从中学习一些好的东西。
    - 完成后，如果有问题需要修复，留 comment “WFF”，表示“waiting for fix”，把MR assign回提交者，否则进行第 4 步。
3. 提交者响应 comments 。
    - 确实有问题的，修复之。如果该分支未被其他人使用，应使用 `git commit --amend` 提交以减少不必要的 commit 历史。
    - 不同意的，讨论。
    - 完成后，留 comment “Fixed”，把MR再次assign给审查者检查，回到第二步。
4. 审查者确认没有问题之后，将 Merge Request 转发给目标分支的维护者进行合并。

### 实战：项目代码分支管理和合并

####  1. 克隆远端的develop分支

```bash
git clone -b develop <remote-repository-name>
```

####  2. 创建新的分支完成task

开始实现一个feature或者解决一个bug之前，首先切换到develop分支上

```bash
git checkout develop
```

创建feature或者bug的分支,并且切换到该分支

```bash
git checkout -b <feature/bug-branch-name>
```

**分支名称需要遵循命名规范:**

* **feature:** 格式遵守`feat-storyID-moduleName`， 例如`feature-4213-member`
* **bug:** 格式遵守`fix-bugID-moduleName`， 例如`fix-4216-product`
* **docs:** 格式遵守`docs-document-description`， 例如`docs-deploy-process`
* **refactor:** 格式遵守`refactor-moduleName-description`， 例如`refactor-member-reward-code`

**More Information:** 分支名称前缀类型(feat,fix等)说明参考commit message的说明

####  3. 完成开发的工作

修改一些文件，添加修改的文件到暂存区(staging area)

```bash
git add .
```

将修改后的文件提交到本地的版本库中

```bash
git commit -am 'Add a new feature'
```

#### 4. 独立分支上合并提交

这里 **特别注意** ，使用rebase命令将你在自己分支上的多次提交合并成一次提交，同时合并develop分支

```bash
git checkout <feature／bug-branch-name>
git rebase -i develop
```

**Notice:** 使用rebase命令将你在feature／bug分支上的多次提交合并成一次， 保证提交的原子性。其中`-i` 参数会提供交互的方式引导，一般你会看到这样的编辑界面

```bash
pick ff76694 feat(venue): add static page for wechat audience module
pick 8e49657 feat(venue): finish the frontend controller for wechat audience module
pick 69f1a3e feat(venue): finish the backend controller for wechat audience module
# Rebase d879706..8e49657 onto d879706
#
# Commands:
#  p, pick = use commit
#  r, reword = use commit, but edit the commit message
#  e, edit = use commit, but stop for amending
#  s, squash = use commit, but meld into previous commit
#  f, fixup = like "squash", but discard this commit's log message
#  x, exec = run command (the rest of the line) using shell
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
```

下面的注释中Command有详细的解释，一般将你要合并的多个提交前面的pick改为squash（如果有多个commit除了第一个是pick其他都是squash），对于我们的示例，修改为

```bash
pick ff76694 feat(venue): add static page for wechat audience module
squash 8e49657 feat(venue): finish the frontend controller for wechat audience module
squash 69f1a3e feat(venue): finish the backend controller for wechat audience module
# Rebase d879706..8e49657 onto d879706
#...
```

保存文件退出编辑，正常情况下这样就完事了，但是如果develop分支上有新的提交和你的工作分支提交发生冲突，就会看到下面的情况

```bash
error: could not apply ff76694... feat(venue): add static page for wechat audience module

When you have resolved this problem, run "git rebase --continue".
If you prefer to skip this patch, run "git rebase --skip" instead.
To check out the original branch and stop rebasing, run "git rebase --abort".
Could not apply ff76694624019140e05cd9d443aa547e62c5c24b... add line 3
```

编辑冲突文件（冲突文件中可能不会列出你在当前分支上所有的改动，只会标出冲突部分），选择需要的部分，保存文件

```bash
git add <modified files>
git rebase --continue
```

之后你会看到类似这样的提示

```bash
feat(venue): add static page for wechat audience module

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# rebase in progress; onto d879706
# You are currently rebasing branch 'feature' on 'd879706'.
#
# Changes to be committed:
#       modified:   test.txt
#
```

这里是让你编辑你第一次提交的comment，更改comment内容后保存退出，紧接着会提示你编辑合并之后commit的comment，你在上一次添加的comment会合并进来，你看到的会是这样的

```bash
# This is a combination of 2 commits.
# The first commit's message is:

# feat(venue): add static page for wechat audience module
# -----change to----->

feat(venue): finish wechat audience module

# This is the 2nd commit message:

# feat(venue): finish the frontend controller for wechat audience module

# This is the 3nd commit message:

# feat(venue): finish the backend controller for wechat audience module

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# rebase in progress; onto d879706
# You are currently editing a commit while rebasing branch 'feature' on 'd879706'.
#
# Changes to be committed:
#       modified:   test.txt
#
```

**去掉多余的comment内容(像示例中一样，只保留一条comment)**，保存退出。将工作分支上的多次提交合并成一次提交，更详细的说明看[这里](http://gitready.com/advanced/2009/02/10/squashing-commits-with-rebase.html)

#### ５. 提交分支，发MR合并请求到develop分支

在本地解决合并之后的冲突，同时仅保留feature本身提交的comment(去除在merge中自动生成的提交信息)，解决冲突后将分支提交到中央仓库

```bash
git push origin <feature／bug-branch-name>
```
在gitlab上手动创建一个新的merge request，指定source branch和target branch，点击`Compare branches and continue`按钮，指定assignee为可以为你review的项目相关负责人或者直接给项目的manager，使用提交的comment作为merge request的title，点击创建按钮创建merge request．
在 **完成code review没有问题之后** 由assignee来删除用于merge的branch同时将merge request合并回develop分支。

如果在review过程中有问题需要修改或者在发merge request过程中有人提交代码，该merge就不能被直接合并。

在本地重新修改并且本地提交修改，再次rebase develop解决冲突，将commit再次合并成一个，强制提交到你的独立分支，重新发merge request

```
# 创建feature分支
git push origin <feat-branch-name> -f
# 创建bugfix分支
git push origin <fix-branch-name> -f
```

### 实战：准备新版本的release

直接在Gitlab上`New Merge Request`，source branch选择`develop`，target branch选择`master`，将MR给 @wyatt.fang

### 实战：线上hotfix流程

#### 1. 从master分支上创建一个hotfix的新分支

```bash
git checkout master
git pull
git checkout -b <hotifx-branch-name>
```

hotfix的分支名称遵循一般分支的命名规范，文档上面已经说明

#### 2. 修复问题

```bash
git add .
git commit -am 'Fix bug #636 use code1'
...
git commit -am 'Fix bug #636 use code2'
git rebase -i HEAD~3
```

HEAD~3代表hotfix的分支头指针之前连续三次的提交，这里通过rebase重写历史，将release分支上的多次提交合并成单次提交，方便master和develop进行合并

#### 3. 将hotfix分支通过发merge request合并到master分支

```bash
git checkout master
git pull
git checkout <hotifx-branch-name>
git rebase master -i
git push origin <hotifx-branch-name> -f
```

根据正常merge request的review流程，在code review以及生产环境[上线流程](http://gitlab-vwork.vivo.xyz/scrm/aug-marketing/wikis/Hot-fix-process)之后，最后由 @wyatt.fang 合并到master分支

#### ４. cherry-pick hotfix分支上commit通过发merge request合并到develop分支

在hotfix已经merge回master分支之后，需要再merge回develop分支

```bash
git checkout <hotifx-branch-name>
git log --oneline
# Copy the latest commit hash
git checkout develop
git pull
git checkout -b <hotifx-merge-develop-branch-name>
git cherry-pick commit-hash-copied-from-hotfix-branch
# Resolve conflicts and push to remote repo
git push origin <hotifx-merge-develop-branch-name> -f
```

确认没有冲突，直接发merge request给 @charlie.zhang

**Notice:** `<hotifx-merge-develop-branch-name>` 使用跟hotfix同样的分支名称，只是在最后需要加上 **-merge-develop** 的后缀，例如`fix-3241-member-merge-develop`